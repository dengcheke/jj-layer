define(["exports","esri/geometry/geometryEngine","esri/geometry/projection","esri/geometry/SpatialReference"],(function(t,e,n,s){"use strict";function r(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var s=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,s.get?s:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var a=i(e),o=i(n),l=r(s);function h(t){return[t>>0&255,t>>8&255,t>>16&255,t>>24&255]}function f(t,e,n){return t+(e-t)*n}class c{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}equals(t){return t.x===this.x&&t.y===this.y}rotateAround(t,e){const n=Math.cos(e),s=Math.sin(e),r=this.x-t.x,i=this.y-t.y;return this.x=r*n-i*s+t.x,this.y=r*s+i*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}}const u=180/Math.PI;let d=1;const y=new Map;function x(t){const e=++d;return y.set(e,t),e}function p(t){if("polyline"!==t.type.toLowerCase())throw new Error("geometry type is not polyline");return t.paths.map((function(t){if(t.length<2)return console.warn("path's point length < 2, ignored"),null;const e=[],n=[],s=[],r={distance:0,d01:new c,d12:new c,n01:new c,n12:new c,l01:0,l12:0},i=new c;for(let e=0;e<t.length;e++){let n=t[e-1],a=t[e],o=t[e+1];if(n)if(o){i.set(o[0]-a[0],o[1]-a[1]),r.l12=i.length(),i.normalize(),r.d12.copy(i),r.n12.set(-i.y,i.x);const{n01:t,n12:e,distance:n}=r,l=t.cross(e)<=0;i.addVectors(t,e).normalize(),i.multiplyScalar(1/t.dot(i));const h=(new c).subVectors(i,t).length();let f,u,d;l?(i.multiplyScalar(-1),f={x:a[0],y:a[1],xOffset:i.x,yOffset:i.y,distance:n,disWidthDelta:null,side:-1,cw:!0,n01:t.clone(),n12:e.clone()},u={x:a[0],y:a[1],xOffset:i.x+2*t.x,yOffset:i.y+2*t.y,distance:n,disWidthDelta:-h,side:1},d={x:a[0],y:a[1],xOffset:i.x+2*e.x,yOffset:i.y+2*e.y,distance:n,disWidthDelta:+h,side:1}):(f={x:a[0],y:a[1],xOffset:i.x,yOffset:i.y,distance:n,disWidthDelta:null,side:1,cw:!1,n01:t.clone(),n12:e.clone()},u={x:a[0],y:a[1],xOffset:i.x-2*t.x,yOffset:i.y-2*t.y,distance:n,disWidthDelta:-h,side:-1},d={x:a[0],y:a[1],xOffset:i.x-2*e.x,yOffset:i.y-2*e.y,distance:n,disWidthDelta:h,side:-1}),s.push([u,f,d])}else{const{distance:t,n01:e}=r;s.push([{x:a[0],y:a[1],xOffset:e.x,yOffset:e.y,distance:t,disWidthDelta:0,side:1},{x:a[0],y:a[1],xOffset:-e.x,yOffset:-e.y,distance:t,disWidthDelta:0,side:-1}])}else i.set(o[0]-a[0],o[1]-a[1]),r.l12=i.length(),i.normalize(),r.d12.copy(i),r.n12.set(-i.y,i.x),s.push([{x:a[0],y:a[1],xOffset:r.n12.x,yOffset:r.n12.y,distance:r.distance,disWidthDelta:0,side:1},{x:a[0],y:a[1],xOffset:-r.n12.x,yOffset:-r.n12.y,distance:r.distance,disWidthDelta:0,side:-1}]);r.distance+=r.l12,r.l01=r.l12,r.l12=0,r.d01.copy(r.d12),r.n01.copy(r.n12)}for(;s.length;){const t=s.shift(),r=s.shift();if(2===r.length){const s=e.length;e.push(t[0],t[1],r[0],r[1]),n.push(s,s+1,s+2,s+1,s+3,s+2)}else{const[i,o]=t,[l,h,f]=r,{n01:c,n12:d,cw:y,xOffset:x,yOffset:p}=h;let g=e.length;y?e.push(i,o,l,{...h,disWidthDelta:l.disWidthDelta}):e.push(i,o,{...h,disWidthDelta:l.disWidthDelta},l),n.push(g,g+1,g+2,g+1,g+3,g+2);const m=Math.acos(c.dot(d))*u,b=m?Math.ceil(m/30):0,w=a(c.clone().multiplyScalar(2*(y?1:-1)),d.clone().multiplyScalar(2*(y?1:-1)),l.disWidthDelta,f.disWidthDelta,y,b+2);for(let t=0;t<w.length-1;t++){const s=w[t],r=w[t+1];g=e.length;const i={...l,xOffset:x+s.vec.x,yOffset:p+s.vec.y,disWidthDelta:s.val},a={...h,disWidthDelta:.5*(s.val+r.val)},o={...l,xOffset:x+r.vec.x,yOffset:p+r.vec.y,disWidthDelta:r.val};e.push(i,a,o),y?n.push(g,g+1,g+2):n.push(g,g+2,g+1)}const O=[{...h,disWidthDelta:f.disWidthDelta},f];y&&O.reverse(),s.unshift(O)}}return e.forEach((t=>{t.yOffset*=-1,delete t.cw,delete t.n01,delete t.n12})),{vertices:e,indices:n,totalDis:r.distance};function a(t,e,n,s,r=!0,i=5){const a=(r?-1:1)*(Math.acos(t.dot(e)/(t.length()*e.length()))||0)/(i-1),o=(s-n)/(i-1),l=Math.cos(a),h=Math.sin(a),f=[];for(let e=0;e<i;e++){let s;if(0===e)s={x:t.x,y:t.y};else{const t=f[e-1].vec;s={x:t.x*l-t.y*h,y:t.x*h+t.y*l}}f.push({vec:s,val:o*e+n})}return f}}))}t.createRasterFlowLineMesh=function({data:t,setting:e,useCache:n,computeSpeedRange:s}){let r,i;if(n?t.data=y.get(t.data):(t.data=new Float64Array(t.data),r=x(t.data)),s){const{data:e,noDataValue:n}=t;let s=1/0,r=-1/0;for(let t=0;t<e.length;t+=2){const i=Math.hypot(e[t]===n?0:e[t],e[t+1]===n?0:e[t+1]);s=Math.min(s,i),r=Math.max(r,i)}i=[s,r]}const a=function(t,e){const n=[],[s,r,i,a]=t.limitRange;let o=1/t.lineCollisionWidth;const l=Math.round((r-s)*o),h=Math.round((a-i)*o),f=new Uint8Array(l*h),c=[];for(let e=i;e<a;e+=t.lineSpacing)for(let n=s;n<r;n+=t.lineSpacing)c.push({x:n,y:e,sort:Math.random()});c.sort(((t,e)=>t.sort-e.sort));const u=function(t){const[e,n,s,r]=t;return(t,i)=>t>=e&&t<=n&&i>=s&&i<=r}(t.limitRange);for(const{x:s,y:r}of c)if(Math.random()<t.density){const i=d(t,e,s,r,f,l,h,o,t.limitRange,u);i.length>3&&n.push(i)}return n}(e,function(t){const{width:e,height:n,data:s,noDataValue:r}=t;return(t,i)=>{const a=new c(t,i).floor();if(a.x<0||a.x>=e||a.y<0||a.y>=n)return[0,0];t-=a.x,i-=a.y;const o=a.x<e-1?1:0,l=a.y<n-1?1:0,h=a.y*e+a.x,u=a.y*e+(a.x+o),d=(a.y+l)*e+a.x,y=(a.y+l)*e+(a.x+o),[x,p,g,m]=[h,d,u,y].map((t=>{const e=s[2*t];return e===r?0:e})),[b,w,O,M]=[h,d,u,y].map((t=>{const e=s[2*t+1];return e===r?0:e}));return[f(f(x,p,i),f(g,m,i),t),f(f(b,w,i),f(O,M,i),t)]}}(t)),{buffer1:o,buffer2:l,buffer3:h,buffer4:u}=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n].length-1;const n=4*e,s=new Float32Array(n),r=new Float32Array(n),i=new Float32Array(n),a=new Float32Array(2*e);let o=0;for(let e=0;e<t.length;e++){const n=t[e],l=n[n.length-1].t,h=Math.random(),f=n.length;for(let t=0,e=f-2;t<=e;t++){const f=4*o,c=f+1,u=f+2,d=f+3,y=0===t?n[0]:n[t-1],x=n[t],p=n[t+1],g=t===e?n[t+1]:n[t+2];s[f]=y.x,s[c]=y.y,s[u]=x.x,s[d]=x.y,r[f]=p.x,r[c]=p.y,r[u]=g.x,r[d]=g.y,i[f]=x.t,i[c]=p.t,i[u]=l,i[d]=h,a[2*o]=x.speed,a[2*o+1]=p.speed,o++}}return{buffer1:s,buffer2:r,buffer3:i,buffer4:a}}(a);return{result:{buffer1:o.buffer,buffer2:l.buffer,buffer3:h.buffer,buffer4:u.buffer,speedRange:i,cacheId:n?null:r},transferList:[o.buffer,l.buffer,h.buffer,u.buffer]};function d(t,e,n,s,r,i,a,o,l,h){const f=[];let u=0;const d=new c(n,s),y=new c,x=new c,p=new c;f.push({x:n,y:s,t:u,speed:p.set(...e(n,s)).length()});for(let n=0;n<t.verticesPerLine&&(!n||h(d.x,d.y));n++){const s=p.set(...e(d.x,d.y)),h=s.length(),c=h*t.velocityScale;if(c<t.minSpeedThreshold)break;s.normalize(),x.copy(s);const g=p.copy(d).addScaledVector(x,t.segmentLength);if(u+=t.segmentLength/(c*t.renderVScale),n&&Math.acos(x.dot(y))>t.maxTurnAngle)break;if(t.mergeLines){const[t,e,n,s]=l,h=Math.round((g.x-t)*o),f=Math.round((g.y-n)*o);if(h<0||h>i-1||f<0||f>a-1)break;if(r[f*i+h]>0)break;r[f*i+h]=1}f.push({x:g.x,y:g.y,t:u,speed:h}),y.copy(x),d.copy(g)}return f}},t.processTINMeshPart=function({data:t,sourceSR:e,targetSR:n,offsetCenter:s,pickIndexOffset:r}){const i=e.wkid===n.wkid;return new Promise((t=>{i?t():o.load().then((()=>t()))})).then((()=>{const[a,l]=s,f=new Float64Array(t),c=f.length/6,u=new Uint8ClampedArray(4*c);for(let t=0;t<c;t++){const e=4*t,n=h(t+1+r);u[e]=n[0],u[e+1]=n[1],u[e+2]=n[2],u[e+3]=n[3]}const d=new Float32Array(f.length);if(i)for(let t=0;t<f.length;t+=2)d[t]=f[t]-a,d[t+1]=f[t+1]-l;else for(let t=0;t<f.length;t+=2){const s=o.project({x:f[t],y:f[t+1],spatialReference:e},n);d[t]=s.x-a,d[t+1]=s.y-l}return{result:{vertexBuffer:d.buffer,pickBuffer:u.buffer},transferList:[d.buffer,u.buffer]}}))},t.removeCache=function(t){y.delete(t)},t.setCache=x,t.tessellateFlowLine=function(t){return o.load().then((()=>{let{sr:e,geometry:n}=JSON.parse(t);return e=new l.default(e),n=a.simplify(n),e.equals(n.spatialReference)||(n=o.project(n,e)),{mesh:p(n),extent:n.extent.toJSON()}}))},Object.defineProperty(t,"__esModule",{value:!0})}));
