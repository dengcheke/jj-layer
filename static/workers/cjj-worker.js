define(["exports","esri/geometry/geometryEngine","esri/geometry/projection","esri/geometry/SpatialReference"],(function(t,e,s,n){"use strict";function r(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(s){if("default"!==s){var n=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(e,s,n.get?n:{enumerable:!0,get:function(){return t[s]}})}})),e.default=t,Object.freeze(e)}var a=i(e),l=i(s),h=r(n);function o(t,e,s){return Math.max(e,Math.min(s,t))}function f(t,e,s){return t+(e-t)*s}class c{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}equals(t){return t.x===this.x&&t.y===this.y}rotateAround(t,e){const s=Math.cos(e),n=Math.sin(e),r=this.x-t.x,i=this.y-t.y;return this.x=r*s-i*n+t.x,this.y=r*n+i*s+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}}const y=180/Math.PI;function u(t){if("polyline"!==t.type.toLowerCase())throw new Error("geometry type is not polyline");return t.paths.map((function(t){if(t.length<2)return console.warn("path's point length < 2, ignored"),null;const e=[],s=[],n=[],r={distance:0,d01:new c,d12:new c,n01:new c,n12:new c,l01:0,l12:0},i=new c;for(let e=0;e<t.length;e++){let s=t[e-1],a=t[e],l=t[e+1];if(s)if(l){i.set(l[0]-a[0],l[1]-a[1]),r.l12=i.length(),i.normalize(),r.d12.copy(i),r.n12.set(-i.y,i.x);const{n01:t,n12:e,distance:s}=r,h=t.cross(e)<=0;i.addVectors(t,e).normalize(),i.multiplyScalar(1/t.dot(i));const o=(new c).subVectors(i,t).length();let f,y,u;h?(i.multiplyScalar(-1),f={x:a[0],y:a[1],xOffset:i.x,yOffset:i.y,distance:s,disWidthDelta:null,side:-1,cw:!0,n01:t.clone(),n12:e.clone()},y={x:a[0],y:a[1],xOffset:i.x+2*t.x,yOffset:i.y+2*t.y,distance:s,disWidthDelta:-o,side:1},u={x:a[0],y:a[1],xOffset:i.x+2*e.x,yOffset:i.y+2*e.y,distance:s,disWidthDelta:+o,side:1}):(f={x:a[0],y:a[1],xOffset:i.x,yOffset:i.y,distance:s,disWidthDelta:null,side:1,cw:!1,n01:t.clone(),n12:e.clone()},y={x:a[0],y:a[1],xOffset:i.x-2*t.x,yOffset:i.y-2*t.y,distance:s,disWidthDelta:-o,side:-1},u={x:a[0],y:a[1],xOffset:i.x-2*e.x,yOffset:i.y-2*e.y,distance:s,disWidthDelta:o,side:-1}),n.push([y,f,u])}else{const{distance:t,n01:e}=r;n.push([{x:a[0],y:a[1],xOffset:e.x,yOffset:e.y,distance:t,disWidthDelta:0,side:1},{x:a[0],y:a[1],xOffset:-e.x,yOffset:-e.y,distance:t,disWidthDelta:0,side:-1}])}else i.set(l[0]-a[0],l[1]-a[1]),r.l12=i.length(),i.normalize(),r.d12.copy(i),r.n12.set(-i.y,i.x),n.push([{x:a[0],y:a[1],xOffset:r.n12.x,yOffset:r.n12.y,distance:r.distance,disWidthDelta:0,side:1},{x:a[0],y:a[1],xOffset:-r.n12.x,yOffset:-r.n12.y,distance:r.distance,disWidthDelta:0,side:-1}]);r.distance+=r.l12,r.l01=r.l12,r.l12=0,r.d01.copy(r.d12),r.n01.copy(r.n12)}for(;n.length;){const t=n.shift(),r=n.shift();if(2===r.length){const n=e.length;e.push(t[0],t[1],r[0],r[1]),s.push(n,n+1,n+2,n+1,n+3,n+2)}else{const[i,l]=t,[h,o,f]=r,{n01:c,n12:u,cw:d,xOffset:x,yOffset:p}=o;let g=e.length;d?e.push(i,l,h,{...o,disWidthDelta:h.disWidthDelta}):e.push(i,l,{...o,disWidthDelta:h.disWidthDelta},h),s.push(g,g+1,g+2,g+1,g+3,g+2);const m=Math.acos(c.dot(u))*y,w=m?Math.ceil(m/30):0,O=a(c.clone().multiplyScalar(2*(d?1:-1)),u.clone().multiplyScalar(2*(d?1:-1)),h.disWidthDelta,f.disWidthDelta,d,w+2);for(let t=0;t<O.length-1;t++){const n=O[t],r=O[t+1];g=e.length;const i={...h,xOffset:x+n.vec.x,yOffset:p+n.vec.y,disWidthDelta:n.val},a={...o,disWidthDelta:.5*(n.val+r.val)},l={...h,xOffset:x+r.vec.x,yOffset:p+r.vec.y,disWidthDelta:r.val};e.push(i,a,l),d?s.push(g,g+1,g+2):s.push(g,g+2,g+1)}const b=[{...o,disWidthDelta:f.disWidthDelta},f];d&&b.reverse(),n.unshift(b)}}return e.forEach((t=>{t.yOffset*=-1,delete t.cw,delete t.n01,delete t.n12})),{vertices:e,indices:s,totalDis:r.distance};function a(t,e,s,n,r=!0,i=5){const a=(r?-1:1)*(Math.acos(t.dot(e)/(t.length()*e.length()))||0)/(i-1),l=(n-s)/(i-1),h=Math.cos(a),o=Math.sin(a),f=[];for(let e=0;e<i;e++){let n;if(0===e)n={x:t.x,y:t.y};else{const t=f[e-1].vec;n={x:t.x*h-t.y*o,y:t.x*o+t.y*h}}f.push({vec:n,val:l*e+s})}return f}}))}t.createRasterFlowLineMesh=function({data:t,setting:e}){t.data=new Float32Array(t.data);const s=function(t,e,s,n){const r=[],[i,l,h,f]=t.limitRange;let c=1/t.lineCollisionWidth;c>1&&(c=Math.min(c**.5,10));const y=Math.round((l-i)*c),u=Math.round((f-h)*c),d=new Uint8Array(y*u),x=[];for(let e=0;e<n;e+=t.lineSpacing)if(e===o(e,h,f))for(let n=0;n<s;n+=t.lineSpacing)n===o(n,i,l)&&x.push({x:n,y:e,sort:Math.random()});x.sort(((t,e)=>t.sort-e.sort));const p=function(t){const[e,s,n,r]=t;return(t,i)=>t>=e&&t<=s&&i>=n&&i<=r}(t.limitRange);for(const{x:s,y:n}of x)if(Math.random()<t.density){const i=a(t,e,s,n,d,y,u,c,t.limitRange,p);i.length>2&&r.push(i)}return r}(e,function(t){const{width:e,height:s,data:n,noDataValue:r}=t;return(t,i)=>{const a=new c(t,i).floor();if(a.x<0||a.x>=e||a.y<0||a.y>=s)return[0,0];t-=a.x,i-=a.y;const l=a.x<e-1?1:0,h=a.y<s-1?1:0,o=a.y*e+a.x,y=a.y*e+(a.x+l),u=(a.y+h)*e+a.x,d=(a.y+h)*e+(a.x+l),[x,p,g,m]=[o,u,y,d].map((t=>{const e=n[2*t];return e===r?0:e})),[w,O,b,M]=[o,u,y,d].map((t=>{const e=n[2*t+1];return e===r?0:e}));return[f(f(x,p,i),f(g,m,i),t),f(f(w,O,i),f(b,M,i),t)]}}(t),t.width,t.height),{buffer1:n,buffer2:r,buffer3:i}=function(t){let e=0;for(let s=0;s<t.length;s++)e+=t[s].length-1;const s=4*e,n=new Float32Array(s),r=new Float32Array(s),i=new Float32Array(s);let a=0;for(let e=0;e<t.length;e++){const s=t[e],l=s[s.length-1].t,h=Math.random(),o=s.length;for(let t=0,e=o-2;t<=e;t++){const o=4*a,f=o+1,c=o+2,y=o+3,u=0===t?s[0]:s[t-1],d=s[t],x=s[t+1],p=t===e?s[t+1]:s[t+2];n[o]=u.x,n[f]=u.y,n[c]=d.x,n[y]=d.y,r[o]=x.x,r[f]=x.y,r[c]=p.x,r[y]=p.y,i[o]=d.t,i[f]=x.t,i[c]=l,i[y]=h,a++}}return{buffer1:n,buffer2:r,buffer3:i}}(s);return{result:{buffer1:n.buffer,buffer2:r.buffer,buffer3:i.buffer},transferList:[n.buffer,r.buffer,i.buffer]};function a(t,e,s,n,r,i,a,l,h,o){const f=[];let y=0;const u=new c(s,n),d=new c,x=new c,p=new c;f.push({x:s,y:n,t:y});for(let s=0;s<t.verticesPerLine&&(!s||o(u.x,u.y));s++){const n=p.set(...e(u.x,u.y)).multiplyScalar(t.velocityScale),o=n.length();if(o<t.minSpeedThreshold)break;x.copy(n).multiplyScalar(1/o);const c=p.copy(u).addScaledVector(x,t.segmentLength);if(y+=t.segmentLength/o,s&&Math.acos(x.dot(d))>t.maxTurnAngle)break;if(t.mergeLines){const[t,e,s,n]=h,o=Math.round((c.x-t)*l),f=Math.round((c.y-s)*l);if(o<0||o>i-1||f<0||f>a-1)break;if(r[f*i+o]>0)break;r[f*i+o]=1}f.push({x:c.x,y:c.y,t:y}),d.copy(x),u.copy(c)}return f}},t.processTINMeshPart=function({data:t,sourceSR:e,targetSR:s,offsetCenter:n,pickIndexOffset:r}){const i=e.wkid===s.wkid;return new Promise((t=>{i?t():l.load().then((()=>t()))})).then((()=>{const[a,h]=n,o=new Float64Array(t),f=o.length/6,c=new Uint8ClampedArray(4*f);for(let t=0;t<f;t++){const e=4*t,s=[(y=t+1+r)>>0&255,y>>8&255,y>>16&255,y>>24&255];c[e]=s[0],c[e+1]=s[1],c[e+2]=s[2],c[e+3]=s[3]}var y;const u=new Float32Array(o.length);if(i)for(let t=0;t<o.length;t+=2)u[t]=o[t]-a,u[t+1]=o[t+1]-h;else for(let t=0;t<o.length;t+=2){const n=l.project({x:o[t],y:o[t+1],spatialReference:e},s);u[t]=n.x-a,u[t+1]=n.y-h}return{result:{vertexBuffer:u.buffer,pickBuffer:c.buffer},transferList:[u.buffer,c.buffer]}}))},t.tessellateFlowLine=function(t){return l.load().then((()=>{let{sr:e,geometry:s}=JSON.parse(t);return e=new h.default(e),s=a.simplify(s),e.equals(s.spatialReference)||(s=l.project(s,e)),{mesh:u(s),extent:s.extent.toJSON()}}))},Object.defineProperty(t,"__esModule",{value:!0})}));
