define(["exports","esri/geometry/geometryEngine","esri/geometry/projection","esri/geometry/SpatialReference"],(function(t,e,n,s){"use strict";function r(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var s=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,s.get?s:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var a=i(e),l=i(n),o=r(s);function h(t){return[t>>0&255,t>>8&255,t>>16&255,t>>24&255]}function f(t,e,n){return Math.max(e,Math.min(n,t))}function c(t,e,n){return t+(e-t)*n}class u{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}equals(t){return t.x===this.x&&t.y===this.y}rotateAround(t,e){const n=Math.cos(e),s=Math.sin(e),r=this.x-t.x,i=this.y-t.y;return this.x=r*n-i*s+t.x,this.y=r*s+i*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}}const d=180/Math.PI;let y=1;const x=new Map;function p(t){const e=++y;return x.set(e,t),e}function g(t){if("polyline"!==t.type.toLowerCase())throw new Error("geometry type is not polyline");return t.paths.map((function(t){if(t.length<2)return console.warn("path's point length < 2, ignored"),null;const e=[],n=[],s=[],r={distance:0,d01:new u,d12:new u,n01:new u,n12:new u,l01:0,l12:0},i=new u;for(let e=0;e<t.length;e++){let n=t[e-1],a=t[e],l=t[e+1];if(n)if(l){i.set(l[0]-a[0],l[1]-a[1]),r.l12=i.length(),i.normalize(),r.d12.copy(i),r.n12.set(-i.y,i.x);const{n01:t,n12:e,distance:n}=r,o=t.cross(e)<=0;i.addVectors(t,e).normalize(),i.multiplyScalar(1/t.dot(i));const h=(new u).subVectors(i,t).length();let f,c,d;o?(i.multiplyScalar(-1),f={x:a[0],y:a[1],xOffset:i.x,yOffset:i.y,distance:n,disWidthDelta:null,side:-1,cw:!0,n01:t.clone(),n12:e.clone()},c={x:a[0],y:a[1],xOffset:i.x+2*t.x,yOffset:i.y+2*t.y,distance:n,disWidthDelta:-h,side:1},d={x:a[0],y:a[1],xOffset:i.x+2*e.x,yOffset:i.y+2*e.y,distance:n,disWidthDelta:+h,side:1}):(f={x:a[0],y:a[1],xOffset:i.x,yOffset:i.y,distance:n,disWidthDelta:null,side:1,cw:!1,n01:t.clone(),n12:e.clone()},c={x:a[0],y:a[1],xOffset:i.x-2*t.x,yOffset:i.y-2*t.y,distance:n,disWidthDelta:-h,side:-1},d={x:a[0],y:a[1],xOffset:i.x-2*e.x,yOffset:i.y-2*e.y,distance:n,disWidthDelta:h,side:-1}),s.push([c,f,d])}else{const{distance:t,n01:e}=r;s.push([{x:a[0],y:a[1],xOffset:e.x,yOffset:e.y,distance:t,disWidthDelta:0,side:1},{x:a[0],y:a[1],xOffset:-e.x,yOffset:-e.y,distance:t,disWidthDelta:0,side:-1}])}else i.set(l[0]-a[0],l[1]-a[1]),r.l12=i.length(),i.normalize(),r.d12.copy(i),r.n12.set(-i.y,i.x),s.push([{x:a[0],y:a[1],xOffset:r.n12.x,yOffset:r.n12.y,distance:r.distance,disWidthDelta:0,side:1},{x:a[0],y:a[1],xOffset:-r.n12.x,yOffset:-r.n12.y,distance:r.distance,disWidthDelta:0,side:-1}]);r.distance+=r.l12,r.l01=r.l12,r.l12=0,r.d01.copy(r.d12),r.n01.copy(r.n12)}for(;s.length;){const t=s.shift(),r=s.shift();if(2===r.length){const s=e.length;e.push(t[0],t[1],r[0],r[1]),n.push(s,s+1,s+2,s+1,s+3,s+2)}else{const[i,l]=t,[o,h,f]=r,{n01:c,n12:u,cw:y,xOffset:x,yOffset:p}=h;let g=e.length;y?e.push(i,l,o,{...h,disWidthDelta:o.disWidthDelta}):e.push(i,l,{...h,disWidthDelta:o.disWidthDelta},o),n.push(g,g+1,g+2,g+1,g+3,g+2);const m=Math.acos(c.dot(u))*d,b=m?Math.ceil(m/30):0,w=a(c.clone().multiplyScalar(2*(y?1:-1)),u.clone().multiplyScalar(2*(y?1:-1)),o.disWidthDelta,f.disWidthDelta,y,b+2);for(let t=0;t<w.length-1;t++){const s=w[t],r=w[t+1];g=e.length;const i={...o,xOffset:x+s.vec.x,yOffset:p+s.vec.y,disWidthDelta:s.val},a={...h,disWidthDelta:.5*(s.val+r.val)},l={...o,xOffset:x+r.vec.x,yOffset:p+r.vec.y,disWidthDelta:r.val};e.push(i,a,l),y?n.push(g,g+1,g+2):n.push(g,g+2,g+1)}const O=[{...h,disWidthDelta:f.disWidthDelta},f];y&&O.reverse(),s.unshift(O)}}return e.forEach((t=>{t.yOffset*=-1,delete t.cw,delete t.n01,delete t.n12})),{vertices:e,indices:n,totalDis:r.distance};function a(t,e,n,s,r=!0,i=5){const a=(r?-1:1)*(Math.acos(t.dot(e)/(t.length()*e.length()))||0)/(i-1),l=(s-n)/(i-1),o=Math.cos(a),h=Math.sin(a),f=[];for(let e=0;e<i;e++){let s;if(0===e)s={x:t.x,y:t.y};else{const t=f[e-1].vec;s={x:t.x*o-t.y*h,y:t.x*h+t.y*o}}f.push({vec:s,val:l*e+n})}return f}}))}t.createRasterFlowLineMesh=function({data:t,setting:e,useCache:n,computeSpeedRange:s}){let r,i;if(n?t.data=x.get(t.data):(t.data=new Float64Array(t.data),r=p(t.data)),s){const{data:e,noDataValue:n}=t;let s=1/0,r=-1/0;for(let t=0;t<e.length;t+=2){const i=Math.hypot(e[t]===n?0:e[t],e[t+1]===n?0:e[t+1]);s=Math.min(s,i),r=Math.max(r,i)}i=[s,r]}const a=function(t,e,n,s){const r=[],[i,a,l,o]=t.limitRange;let h=1/t.lineCollisionWidth;h>1&&(h=Math.min(h**.5,10));const c=Math.round((a-i)*h),u=Math.round((o-l)*h),d=new Uint8Array(c*u),x=[];for(let e=0;e<s;e+=t.lineSpacing)if(e===f(e,l,o))for(let s=0;s<n;s+=t.lineSpacing)s===f(s,i,a)&&x.push({x:s,y:e,sort:Math.random()});x.sort(((t,e)=>t.sort-e.sort));const p=function(t){const[e,n,s,r]=t;return(t,i)=>t>=e&&t<=n&&i>=s&&i<=r}(t.limitRange);for(const{x:n,y:s}of x)if(Math.random()<t.density){const i=y(t,e,n,s,d,c,u,h,t.limitRange,p);i.length>2&&r.push(i)}return r}(e,function(t){const{width:e,height:n,data:s,noDataValue:r}=t;return(t,i)=>{const a=new u(t,i).floor();if(a.x<0||a.x>=e||a.y<0||a.y>=n)return[0,0];t-=a.x,i-=a.y;const l=a.x<e-1?1:0,o=a.y<n-1?1:0,h=a.y*e+a.x,f=a.y*e+(a.x+l),d=(a.y+o)*e+a.x,y=(a.y+o)*e+(a.x+l),[x,p,g,m]=[h,d,f,y].map((t=>{const e=s[2*t];return e===r?0:e})),[b,w,O,M]=[h,d,f,y].map((t=>{const e=s[2*t+1];return e===r?0:e}));return[c(c(x,p,i),c(g,m,i),t),c(c(b,w,i),c(O,M,i),t)]}}(t),t.width,t.height),{buffer1:l,buffer2:o,buffer3:h,buffer4:d}=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n].length-1;const n=4*e,s=new Float32Array(n),r=new Float32Array(n),i=new Float32Array(n),a=new Float32Array(2*e);let l=0;for(let e=0;e<t.length;e++){const n=t[e],o=n[n.length-1].t,h=Math.random(),f=n.length;for(let t=0,e=f-2;t<=e;t++){const f=4*l,c=f+1,u=f+2,d=f+3,y=0===t?n[0]:n[t-1],x=n[t],p=n[t+1],g=t===e?n[t+1]:n[t+2];s[f]=y.x,s[c]=y.y,s[u]=x.x,s[d]=x.y,r[f]=p.x,r[c]=p.y,r[u]=g.x,r[d]=g.y,i[f]=x.t,i[c]=p.t,i[u]=o,i[d]=h,a[2*l]=x.speed,a[2*l+1]=p.speed,l++}}return{buffer1:s,buffer2:r,buffer3:i,buffer4:a}}(a);return{result:{buffer1:l.buffer,buffer2:o.buffer,buffer3:h.buffer,buffer4:d.buffer,speedRange:i,cacheId:n?null:r},transferList:[l.buffer,o.buffer,h.buffer,d.buffer]};function y(t,e,n,s,r,i,a,l,o,h){const f=[];let c=0;const d=new u(n,s),y=new u,x=new u,p=new u;f.push({x:n,y:s,t:c,speed:p.set(...e(n,s)).length()});for(let n=0;n<t.verticesPerLine&&(!n||h(d.x,d.y));n++){const s=p.set(...e(d.x,d.y)),h=s.length();s.multiplyScalar(t.velocityScale);const u=s.length();if(u<t.minSpeedThreshold)break;x.copy(s).multiplyScalar(1/u);const g=p.copy(d).addScaledVector(x,t.segmentLength);if(c+=t.segmentLength/u,n&&Math.acos(x.dot(y))>t.maxTurnAngle)break;if(t.mergeLines){const[t,e,n,s]=o,h=Math.round((g.x-t)*l),f=Math.round((g.y-n)*l);if(h<0||h>i-1||f<0||f>a-1)break;if(r[f*i+h]>0)break;r[f*i+h]=1}f.push({x:g.x,y:g.y,t:c,speed:h}),y.copy(x),d.copy(g)}return f}},t.processTINMeshPart=function({data:t,sourceSR:e,targetSR:n,offsetCenter:s,pickIndexOffset:r}){const i=e.wkid===n.wkid;return new Promise((t=>{i?t():l.load().then((()=>t()))})).then((()=>{const[a,o]=s,f=new Float64Array(t),c=f.length/6,u=new Uint8ClampedArray(4*c);for(let t=0;t<c;t++){const e=4*t,n=h(t+1+r);u[e]=n[0],u[e+1]=n[1],u[e+2]=n[2],u[e+3]=n[3]}const d=new Float32Array(f.length);if(i)for(let t=0;t<f.length;t+=2)d[t]=f[t]-a,d[t+1]=f[t+1]-o;else for(let t=0;t<f.length;t+=2){const s=l.project({x:f[t],y:f[t+1],spatialReference:e},n);d[t]=s.x-a,d[t+1]=s.y-o}return{result:{vertexBuffer:d.buffer,pickBuffer:u.buffer},transferList:[d.buffer,u.buffer]}}))},t.removeCache=function(t){x.delete(t)},t.setCache=p,t.tessellateFlowLine=function(t){return l.load().then((()=>{let{sr:e,geometry:n}=JSON.parse(t);return e=new o.default(e),n=a.simplify(n),e.equals(n.spatialReference)||(n=l.project(n,e)),{mesh:g(n),extent:n.extent.toJSON()}}))},Object.defineProperty(t,"__esModule",{value:!0})}));
