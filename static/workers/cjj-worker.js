define(["exports","esri/geometry/geometryEngine","esri/geometry/projection","esri/geometry/SpatialReference"],(function(t,e,n,s){"use strict";function r(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function i(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var s=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,s.get?s:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var a=i(e),l=i(n),o=r(s);function h(t){return[t>>0&255,t>>8&255,t>>16&255,t>>24&255]}function c(t,e,n){return Math.max(e,Math.min(n,t))}function f(t,e,n){return t+(e-t)*n}class u{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}equals(t){return t.x===this.x&&t.y===this.y}rotateAround(t,e){const n=Math.cos(e),s=Math.sin(e),r=this.x-t.x,i=this.y-t.y;return this.x=r*n-i*s+t.x,this.y=r*s+i*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}}const y=180/Math.PI;let d=1;const x=new Map;function p(t){const e=++d;return x.set(e,t),e}function g(t){if("polyline"!==t.type.toLowerCase())throw new Error("geometry type is not polyline");return t.paths.map((function(t){if(t.length<2)return console.warn("path's point length < 2, ignored"),null;const e=[],n=[],s=[],r={distance:0,d01:new u,d12:new u,n01:new u,n12:new u,l01:0,l12:0},i=new u;for(let e=0;e<t.length;e++){let n=t[e-1],a=t[e],l=t[e+1];if(n)if(l){i.set(l[0]-a[0],l[1]-a[1]),r.l12=i.length(),i.normalize(),r.d12.copy(i),r.n12.set(-i.y,i.x);const{n01:t,n12:e,distance:n}=r,o=t.cross(e)<=0;i.addVectors(t,e).normalize(),i.multiplyScalar(1/t.dot(i));const h=(new u).subVectors(i,t).length();let c,f,y;o?(i.multiplyScalar(-1),c={x:a[0],y:a[1],xOffset:i.x,yOffset:i.y,distance:n,disWidthDelta:null,side:-1,cw:!0,n01:t.clone(),n12:e.clone()},f={x:a[0],y:a[1],xOffset:i.x+2*t.x,yOffset:i.y+2*t.y,distance:n,disWidthDelta:-h,side:1},y={x:a[0],y:a[1],xOffset:i.x+2*e.x,yOffset:i.y+2*e.y,distance:n,disWidthDelta:+h,side:1}):(c={x:a[0],y:a[1],xOffset:i.x,yOffset:i.y,distance:n,disWidthDelta:null,side:1,cw:!1,n01:t.clone(),n12:e.clone()},f={x:a[0],y:a[1],xOffset:i.x-2*t.x,yOffset:i.y-2*t.y,distance:n,disWidthDelta:-h,side:-1},y={x:a[0],y:a[1],xOffset:i.x-2*e.x,yOffset:i.y-2*e.y,distance:n,disWidthDelta:h,side:-1}),s.push([f,c,y])}else{const{distance:t,n01:e}=r;s.push([{x:a[0],y:a[1],xOffset:e.x,yOffset:e.y,distance:t,disWidthDelta:0,side:1},{x:a[0],y:a[1],xOffset:-e.x,yOffset:-e.y,distance:t,disWidthDelta:0,side:-1}])}else i.set(l[0]-a[0],l[1]-a[1]),r.l12=i.length(),i.normalize(),r.d12.copy(i),r.n12.set(-i.y,i.x),s.push([{x:a[0],y:a[1],xOffset:r.n12.x,yOffset:r.n12.y,distance:r.distance,disWidthDelta:0,side:1},{x:a[0],y:a[1],xOffset:-r.n12.x,yOffset:-r.n12.y,distance:r.distance,disWidthDelta:0,side:-1}]);r.distance+=r.l12,r.l01=r.l12,r.l12=0,r.d01.copy(r.d12),r.n01.copy(r.n12)}for(;s.length;){const t=s.shift(),r=s.shift();if(2===r.length){const s=e.length;e.push(t[0],t[1],r[0],r[1]),n.push(s,s+1,s+2,s+1,s+3,s+2)}else{const[i,l]=t,[o,h,c]=r,{n01:f,n12:u,cw:d,xOffset:x,yOffset:p}=h;let g=e.length;d?e.push(i,l,o,{...h,disWidthDelta:o.disWidthDelta}):e.push(i,l,{...h,disWidthDelta:o.disWidthDelta},o),n.push(g,g+1,g+2,g+1,g+3,g+2);const m=Math.acos(f.dot(u))*y,w=m?Math.ceil(m/30):0,O=a(f.clone().multiplyScalar(2*(d?1:-1)),u.clone().multiplyScalar(2*(d?1:-1)),o.disWidthDelta,c.disWidthDelta,d,w+2);for(let t=0;t<O.length-1;t++){const s=O[t],r=O[t+1];g=e.length;const i={...o,xOffset:x+s.vec.x,yOffset:p+s.vec.y,disWidthDelta:s.val},a={...h,disWidthDelta:.5*(s.val+r.val)},l={...o,xOffset:x+r.vec.x,yOffset:p+r.vec.y,disWidthDelta:r.val};e.push(i,a,l),d?n.push(g,g+1,g+2):n.push(g,g+2,g+1)}const b=[{...h,disWidthDelta:c.disWidthDelta},c];d&&b.reverse(),s.unshift(b)}}return e.forEach((t=>{t.yOffset*=-1,delete t.cw,delete t.n01,delete t.n12})),{vertices:e,indices:n,totalDis:r.distance};function a(t,e,n,s,r=!0,i=5){const a=(r?-1:1)*(Math.acos(t.dot(e)/(t.length()*e.length()))||0)/(i-1),l=(s-n)/(i-1),o=Math.cos(a),h=Math.sin(a),c=[];for(let e=0;e<i;e++){let s;if(0===e)s={x:t.x,y:t.y};else{const t=c[e-1].vec;s={x:t.x*o-t.y*h,y:t.x*h+t.y*o}}c.push({vec:s,val:l*e+n})}return c}}))}t.createRasterFlowLineMesh=function({data:t,setting:e,useCache:n}){let s;n?t.data=x.get(t.data):(t.data=new Float64Array(t.data),s=p(t.data));const r=function(t,e,n,s){const r=[],[i,a,l,h]=t.limitRange;let f=1/t.lineCollisionWidth;f>1&&(f=Math.min(f**.5,10));const u=Math.round((a-i)*f),y=Math.round((h-l)*f),d=new Uint8Array(u*y),x=[];for(let e=0;e<s;e+=t.lineSpacing)if(e===c(e,l,h))for(let s=0;s<n;s+=t.lineSpacing)s===c(s,i,a)&&x.push({x:s,y:e,sort:Math.random()});x.sort(((t,e)=>t.sort-e.sort));const p=function(t){const[e,n,s,r]=t;return(t,i)=>t>=e&&t<=n&&i>=s&&i<=r}(t.limitRange);for(const{x:n,y:s}of x)if(Math.random()<t.density){const i=o(t,e,n,s,d,u,y,f,t.limitRange,p);i.length>2&&r.push(i)}return r}(e,function(t){const{width:e,height:n,data:s,noDataValue:r}=t;return(t,i)=>{const a=new u(t,i).floor();if(a.x<0||a.x>=e||a.y<0||a.y>=n)return[0,0];t-=a.x,i-=a.y;const l=a.x<e-1?1:0,o=a.y<n-1?1:0,h=a.y*e+a.x,c=a.y*e+(a.x+l),y=(a.y+o)*e+a.x,d=(a.y+o)*e+(a.x+l),[x,p,g,m]=[h,y,c,d].map((t=>{const e=s[2*t];return e===r?0:e})),[w,O,b,M]=[h,y,c,d].map((t=>{const e=s[2*t+1];return e===r?0:e}));return[f(f(x,p,i),f(g,m,i),t),f(f(w,O,i),f(b,M,i),t)]}}(t),t.width,t.height),{buffer1:i,buffer2:a,buffer3:l}=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n].length-1;const n=4*e,s=new Float32Array(n),r=new Float32Array(n),i=new Float32Array(n);let a=0;for(let e=0;e<t.length;e++){const n=t[e],l=n[n.length-1].t,o=Math.random(),h=n.length;for(let t=0,e=h-2;t<=e;t++){const h=4*a,c=h+1,f=h+2,u=h+3,y=0===t?n[0]:n[t-1],d=n[t],x=n[t+1],p=t===e?n[t+1]:n[t+2];s[h]=y.x,s[c]=y.y,s[f]=d.x,s[u]=d.y,r[h]=x.x,r[c]=x.y,r[f]=p.x,r[u]=p.y,i[h]=d.t,i[c]=x.t,i[f]=l,i[u]=o,a++}}return{buffer1:s,buffer2:r,buffer3:i}}(r);return{result:{buffer1:i.buffer,buffer2:a.buffer,buffer3:l.buffer,cacheId:n?null:s},transferList:[i.buffer,a.buffer,l.buffer]};function o(t,e,n,s,r,i,a,l,o,h){const c=[];let f=0;const y=new u(n,s),d=new u,x=new u,p=new u;c.push({x:n,y:s,t:f});for(let n=0;n<t.verticesPerLine&&(!n||h(y.x,y.y));n++){const s=p.set(...e(y.x,y.y)).multiplyScalar(t.velocityScale),h=s.length();if(h<t.minSpeedThreshold)break;x.copy(s).multiplyScalar(1/h);const u=p.copy(y).addScaledVector(x,t.segmentLength);if(f+=t.segmentLength/h,n&&Math.acos(x.dot(d))>t.maxTurnAngle)break;if(t.mergeLines){const[t,e,n,s]=o,h=Math.round((u.x-t)*l),c=Math.round((u.y-n)*l);if(h<0||h>i-1||c<0||c>a-1)break;if(r[c*i+h]>0)break;r[c*i+h]=1}c.push({x:u.x,y:u.y,t:f}),d.copy(x),y.copy(u)}return c}},t.processTINMeshPart=function({data:t,sourceSR:e,targetSR:n,offsetCenter:s,pickIndexOffset:r}){const i=e.wkid===n.wkid;return new Promise((t=>{i?t():l.load().then((()=>t()))})).then((()=>{const[a,o]=s,c=new Float64Array(t),f=c.length/6,u=new Uint8ClampedArray(4*f);for(let t=0;t<f;t++){const e=4*t,n=h(t+1+r);u[e]=n[0],u[e+1]=n[1],u[e+2]=n[2],u[e+3]=n[3]}const y=new Float32Array(c.length);if(i)for(let t=0;t<c.length;t+=2)y[t]=c[t]-a,y[t+1]=c[t+1]-o;else for(let t=0;t<c.length;t+=2){const s=l.project({x:c[t],y:c[t+1],spatialReference:e},n);y[t]=s.x-a,y[t+1]=s.y-o}return{result:{vertexBuffer:y.buffer,pickBuffer:u.buffer},transferList:[y.buffer,u.buffer]}}))},t.removeCache=function(t){x.delete(t)},t.setCache=p,t.tessellateFlowLine=function(t){return l.load().then((()=>{let{sr:e,geometry:n}=JSON.parse(t);return e=new o.default(e),n=a.simplify(n),e.equals(n.spatialReference)||(n=l.project(n,e)),{mesh:g(n),extent:n.extent.toJSON()}}))},Object.defineProperty(t,"__esModule",{value:!0})}));
