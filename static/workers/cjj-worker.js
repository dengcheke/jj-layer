define(["exports","esri/geometry/geometryEngine","esri/geometry/projection","esri/geometry/SpatialReference"],(function(t,e,n,r){"use strict";function s(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function o(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var i=o(e),a=o(n),c=s(r);function l(t){return[t>>0&255,t>>8&255,t>>16&255,t>>24&255]}function h(t,e,n){return t+(e-t)*n}class u{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}equals(t){return t.x===this.x&&t.y===this.y}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),s=this.x-t.x,o=this.y-t.y;return this.x=s*n-o*r+t.x,this.y=s*r+o*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}}let f=1;const y=new Map;function d(t){const e=++f;return y.set(e,t),e}const x=15/180*Math.PI;t.createRasterFlowLineMesh=function({data:t,setting:e,useCache:n,computeSpeedRange:r}){let s,o;if(n?t.data=y.get(t.data):(t.data=new Float64Array(t.data),s=d(t.data)),r){const{data:e,noDataValue:n}=t;let r=1/0,s=-1/0;for(let t=0;t<e.length;t+=2){const o=Math.hypot(e[t]===n?0:e[t],e[t+1]===n?0:e[t+1]);r=Math.min(r,o),s=Math.max(s,o)}o=[r,s]}const i=function(t,e){const n=[],[r,s,o,i]=t.limitRange;let a=1/t.lineCollisionWidth;const c=Math.round((s-r)*a),l=Math.round((i-o)*a),h=new Uint8Array(c*l),u=[];for(let e=o;e<i;e+=t.lineSpacing)for(let n=r;n<s;n+=t.lineSpacing)u.push({x:n,y:e,sort:Math.random()});u.sort(((t,e)=>t.sort-e.sort));const f=function(t){const[e,n,r,s]=t;return(t,o)=>t>=e&&t<=n&&o>=r&&o<=s}(t.limitRange);for(const{x:r,y:s}of u)if(Math.random()<t.density){const o=x(t,e,r,s,h,c,l,a,t.limitRange,f);o.length>3&&n.push(o)}return n}(e,function(t){const{width:e,height:n,data:r,noDataValue:s}=t;return(t,o)=>{const i=new u(t,o).floor();if(i.x<0||i.x>=e||i.y<0||i.y>=n)return[0,0];t-=i.x,o-=i.y;const a=i.x<e-1?1:0,c=i.y<n-1?1:0,l=i.y*e+i.x,f=i.y*e+(i.x+a),y=(i.y+c)*e+i.x,d=(i.y+c)*e+(i.x+a),[x,p,m,g]=[l,y,f,d].map((t=>{const e=r[2*t];return e===s?0:e})),[b,w,v,M]=[l,y,f,d].map((t=>{const e=r[2*t+1];return e===s?0:e}));return[h(h(x,p,o),h(m,g,o),t),h(h(b,w,o),h(v,M,o),t)]}}(t)),{buffer1:a,buffer2:c,buffer3:l,buffer4:f}=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n].length-1;const n=4*e,r=new Float32Array(n),s=new Float32Array(n),o=new Float32Array(n),i=new Float32Array(2*e);let a=0;for(let e=0;e<t.length;e++){const n=t[e],c=n[n.length-1].t,l=Math.random(),h=n.length;for(let t=0,e=h-2;t<=e;t++){const h=4*a,u=h+1,f=h+2,y=h+3,d=0===t?n[0]:n[t-1],x=n[t],p=n[t+1],m=t===e?n[t+1]:n[t+2];r[h]=d.x,r[u]=d.y,r[f]=x.x,r[y]=x.y,s[h]=p.x,s[u]=p.y,s[f]=m.x,s[y]=m.y,o[h]=x.t,o[u]=p.t,o[f]=c,o[y]=l,i[2*a]=x.speed,i[2*a+1]=p.speed,a++}}return{buffer1:r,buffer2:s,buffer3:o,buffer4:i}}(i);return{result:{buffer1:a.buffer,buffer2:c.buffer,buffer3:l.buffer,buffer4:f.buffer,speedRange:o,cacheId:n?null:s},transferList:[a.buffer,c.buffer,l.buffer,f.buffer]};function x(t,e,n,r,s,o,i,a,c,l){const h=[];let f=0;const y=new u(n,r),d=new u,x=new u,p=new u;h.push({x:n,y:r,t:f,speed:p.set(...e(n,r)).length()});for(let n=0;n<t.verticesPerLine&&(!n||l(y.x,y.y));n++){const r=p.set(...e(y.x,y.y)),l=r.length(),u=l*t.velocityScale;if(u<t.minSpeedThreshold)break;r.normalize(),x.copy(r);const m=p.copy(y).addScaledVector(x,t.segmentLength);if(f+=t.segmentLength/(u*t.renderVScale),n&&Math.acos(x.dot(d))>t.maxTurnAngle)break;if(t.mergeLines){const[t,e,n,r]=c,l=Math.round((m.x-t)*a),h=Math.round((m.y-n)*a);if(l<0||l>o-1||h<0||h>i-1)break;if(s[h*o+l]>0)break;s[h*o+l]=1}h.push({x:m.x,y:m.y,t:f,speed:l}),d.copy(x),y.copy(m)}return h}},t.processTINMeshPart=function({data:t,sourceSR:e,targetSR:n,offsetCenter:r,pickIndexOffset:s}){const o=e.wkid===n.wkid;return new Promise((t=>{o?t():a.load().then((()=>t()))})).then((()=>{const[i,c]=r,h=new Float64Array(t),u=h.length/6,f=new Uint8ClampedArray(4*u);for(let t=0;t<u;t++){const e=4*t,n=l(t+1+s);f[e]=n[0],f[e+1]=n[1],f[e+2]=n[2],f[e+3]=n[3]}const y=new Float32Array(h.length);if(o)for(let t=0;t<h.length;t+=2)y[t]=h[t]-i,y[t+1]=h[t+1]-c;else for(let t=0;t<h.length;t+=2){const r=a.project({x:h[t],y:h[t+1],spatialReference:e},n);y[t]=r.x-i,y[t+1]=r.y-c}return{result:{vertexBuffer:y.buffer,pickBuffer:f.buffer},transferList:[y.buffer,f.buffer]}}))},t.removeCache=function(t){y.delete(t)},t.setCache=d,t.tessellateFlowLine=function(t){return a.load().then((()=>{let{sr:e,geometry:n}=JSON.parse(t);e=new c.default(e),n=i.simplify(n),e.equals(n.spatialReference)||(n=a.project(n,e));const r=[],s=function(t){if("polyline"!==t.type.toLowerCase())throw new Error("geometry type is not polyline");return t.paths.map((function(t){if(t.length<2)return console.warn("path's point length < 2, ignored"),null;const e=[];let n=0,r=4*(t.length-1),s=6*(t.length-1);{const o=new u,i=new u,a=new u,c=new u,l=new u,h=new u,f=new u,y=new u,d=new u,x=new u,p=new u;o.set(t[1][0]-t[0][0],t[1][1]-t[0][1]),n+=o.length(),o.normalize(),f.set(-o.y,o.x),e.push({isCw:!0,common:{x:t[0][0],y:t[0][1],len:0,index:0},p1:{side:1,offset:[f.x,f.y],delta:0},p2:{side:-1,offset:[-f.x,-f.y],delta:0}});for(let u=1,g=t.length;u<g-1;u++){l.set(t[u][0],t[u][1]);const g=n;h.set(t[u+1][0],t[u+1][1]),c.subVectors(h,l),n+=c.length(),c.normalize();const b=o.cross(c)<=0;i.copy(o),a.copy(c),b?(i.set(-i.y,i.x),a.set(-a.y,a.x)):(i.set(i.y,-i.x),a.set(a.y,-a.x)),f.addVectors(i,a).normalize(),f.multiplyScalar(1/(i.dot(f)||1e-4)),y.copy(f).multiplyScalar(-1),d.copy(y).addScaledVector(i,2),x.copy(y).addScaledVector(a,2);const w=p.subVectors(f,i).length(),v=b?-1:1,M=b?1:-1,S=m(i,a,-w,w,b);r+=2*S.length-1,s+=3*(S.length-1),S.forEach((t=>{const[e,n]=t.vec;t.vec=[y.x+2*e,y.y+2*n]})),e.push({isCw:b,common:{x:l.x,y:l.y,len:g,index:u},c0:{side:v,offset:[y.x,y.y],delta:void 0},c1:{side:M,offset:[d.x,d.y],delta:-w},c2:{side:M,offset:[x.x,x.y],delta:w},sub:S}),o.copy(c)}{const r=t.length-1;l.set(t[r][0],t[r][1]),f.copy(o),f.set(-f.y,f.x),e.push({isCw:!0,common:{x:l.x,y:l.y,len:n,index:r},p1:{side:1,offset:[f.x,f.y],delta:0},p2:{side:-1,offset:[-f.x,-f.y],delta:0}})}}let o=0,i=0,a=null;const c=new Float64Array(8*r),l=new Uint32Array(s),h=e.length;for(let t=1;t<h-1;t++){const n=e[t-1],r=e[t],{p1:s,p2:i}=n,{c0:c,c1:l,c2:h,isCw:u,sub:f}=r,y={...r.common,...c,delta:l.delta},x={...r.common,...l};a=o,d(o++,{...n.common,...s}),d(o++,{...n.common,...i}),d(o++,u?x:y),d(o++,u?y:x),p(a,a+1,a+2,a+1,a+3,a+2),a=o;const m=f.length-1,g=u?1:-1;d(o++,{...r.common,delta:f[0].value,offset:f[0].vec,side:g});for(let t=1;t<=m;t++){const e=f[t-1],n=f[t];d(o++,{...r.common,...c,delta:(e.value+n.value)/2}),d(o++,{...r.common,side:g,delta:n.value,offset:n.vec});const s=a+2*t;u?p(s-2,s-1,s):p(s,s-1,s-2)}c.delta=h.delta,r.p1=u?h:c,r.p2=u?c:h}const f=e[h-2],y=e[h-1];return a=o,d(o++,{...f.common,...f.p1}),d(o++,{...f.common,...f.p2}),d(o++,{...y.common,...y.p1}),d(o++,{...y.common,...y.p2}),p(a,a+1,a+2,a+1,a+3,a+2),{vertex:c,index:l,totalDis:n};function d(t,e){const n=8*t;c[n]=e.x,c[n+1]=e.y,c[n+2]=e.offset[0],c[n+3]=-1*e.offset[1],c[n+4]=e.len,c[n+5]=e.delta,c[n+6]=e.side,c[n+7]=e.index}function p(...t){const e=i;for(let n=0;n<t.length;n++)l[e+n]=t[n];i+=t.length}function m(t,e,n,r,s=!0){const o=Math.acos(t.dot(e)/(t.length()*e.length()))||0,i=Math.max(o/x>>0,1);if(1===i)return[{vec:[t.x,t.y],value:n},{vec:[e.x,e.y],value:r}];const a=(s?-1:1)*o/i,c=(r-n)/i,l=Math.cos(a),h=Math.sin(a),u=[{vec:[t.x,t.y],value:n}];for(let t=1;t<=i;t++){const e=u[t-1],n=e.vec;u.push({vec:[n[0]*l-n[1]*h,n[0]*h+n[1]*l],value:e.value+c})}return u}}))}(n);return s.forEach((t=>{r.push(t.vertex.buffer),r.push(t.index.buffer)})),{result:{mesh:s,extent:n.extent.toJSON()},transferList:r}}))},Object.defineProperty(t,"__esModule",{value:!0})}));
